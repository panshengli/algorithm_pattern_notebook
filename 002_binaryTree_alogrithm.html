<!DOCTYPE html>
<html>
<head>
<title>002_binaryTree_alogrithm.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h2 id="binarytree-algorithm">BinaryTree Algorithm</h2>
<ul>
<li>struct BinaryTree<pre class="hljs"><code><div><span class="hljs-comment">// Definition for a binary tree node.</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>
{</span>
    <span class="hljs-keyword">int</span> val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(<span class="hljs-number">0</span>), left(<span class="hljs-literal">nullptr</span>), right(<span class="hljs-literal">nullptr</span>) {}
    TreeNode(<span class="hljs-keyword">int</span> x) : val(x), left(<span class="hljs-literal">nullptr</span>), right(<span class="hljs-literal">nullptr</span>) {}
    TreeNode(<span class="hljs-keyword">int</span> x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};
</div></code></pre>
</li>
<li>BSTç‰¹ç‚¹ï¼š
<ul>
<li>å·¦å­æ ‘æ‰€æœ‰èŠ‚ç‚¹å°äº(æˆ–ç­‰äº)æ ¹èŠ‚ç‚¹</li>
<li>å³å­æ ‘æ‰€æœ‰èŠ‚ç‚¹å¤§äº(æˆ–ç­‰äº)æ ¹èŠ‚ç‚¹</li>
<li>å¯ç”¨ä¸­åºéå†è¿›è¡Œæ’åº</li>
</ul>
</li>
</ul>
<hr>
<h2 id="%F0%9F%93%91-index">ğŸ“‘ index</h2>
<ul>
<li>äºŒå‰æ ‘éå†
<ul>
<li><a href="#bt">1. [ä»£ç æ¡†æ¶] binary-tree(ç›¸å…³é¢˜å‹#94ï¼ŒäºŒå‰æ ‘ä¸­åºéå†)</a></li>
<li><a href="#bfs">2. [ä»£ç æ¡†æ¶] BFS</a></li>
<li><a href="#mdobt">3. maximum-depth-of-binary-tree(#104)</a></li>
<li><a href="#bbt">4. balanced-binary-tree(#110)</a></li>
<li><a href="#btnps">5. binary-tree-maximum-path-sum(#124)</a></li>
<li><a href="#lcaoabt">6. lowest-common-ancestor-of-a-binary-tree(#236)</a></li>
</ul>
</li>
<li>BFS å±‚æ¬¡åº”ç”¨
<ul>
<li><a href="#btlot">7. binary-tree-level-order-traversal(#102)[ä¸3ç±»ä¼¼]</a></li>
<li><a href="#btlotii">8. binary-tree-level-order-traversal-ii(#107)[ä¸7ç±»ä¼¼]</a></li>
<li><a href="#btzlot">9. binary-tree-zigzag-level-order-traversal(#103)[ä¸8ç±»ä¼¼]</a></li>
</ul>
</li>
<li>äºŒå‰æœç´¢æ ‘åº”ç”¨
<ul>
<li><a href="#vbst">10. validate-binary-search-tree(#98)</a></li>
<li><a href="#iiabst">11. insert-into-a-binary-search-tree(#701)</a></li>
<li><a href="#dniab">12. delete-node-in-a-bst(#450ï¼Œæ³¨æ„ä½“ä¼šä¸T11åŒºåˆ«)</a></li>
</ul>
</li>
</ul>
<hr>
<hr>
<div id="bt" onclick="window.location.hash">
<h4 id="1-%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6-binary-tree%E7%9B%B8%E5%85%B3%E9%A2%98%E5%9E%8B94%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">1. [ä»£ç æ¡†æ¶] binary-tree(ç›¸å…³é¢˜å‹#94ï¼ŒäºŒå‰æ ‘ä¸­åºéå†)</h4>
<ol>
<li>ä¸‰ç§é€’å½’éå†
Refer by <a href="https://blog.csdn.net/u012102306/article/details/52841163">æ›´ç®€å•çš„éé€’å½’éå†äºŒå‰æ ‘çš„æ–¹æ³•</a><pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">order</span><span class="hljs-params">(TreeNode *root, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;path)</span>
</span>{
    <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-comment">// preorderTraversal</span>
        path.push_back(root-&gt;val);
        order(root-&gt;left, path);
        order(root-&gt;right, path);
        <span class="hljs-comment">// inorderTraversal</span>
        order(root-&gt;left, path);
        path.push_back(root-&gt;val);
        order(root-&gt;right, path);
        <span class="hljs-comment">// postorderTraversal</span>
        order(root-&gt;left, path);
        order(root-&gt;right, path);
        path.push_back(root-&gt;val);
    }
}
</div></code></pre>
</li>
<li><strong>æ›´ç®€å•çš„éé€’å½’éå†äºŒå‰æ ‘</strong></li>
</ol>
<ul>
<li>æœ‰é‡åˆå…ƒç´ çš„<strong>å±€éƒ¨æœ‰åº</strong>ä¸€å®šèƒ½å¯¼è‡´<strong>æ•´ä½“æœ‰åº</strong></li>
<li>å°†æ ˆé¡¶å…ƒç´ å–å‡ºï¼Œä½¿ä»¥æ­¤å…ƒç´ ä¸ºâ€œæ ¹â€ç»“ç‚¹çš„å±€éƒ¨æœ‰åºå…¥æ ˆï¼Œä½†è‹¥æ­¤å‰å·²é€šè¿‡è¯¥ç»“ç‚¹å°†å…¶å±€éƒ¨å…¥æ ˆï¼Œåˆ™ç›´æ¥å‡ºæ ˆè¾“å‡ºå³å¯ã€‚<pre class="hljs"><code><div><span class="hljs-comment">// éé€’å½’éå†</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">orderTraversal</span><span class="hljs-params">(TreeNode *root, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;path)</span>
</span>{
    <span class="hljs-built_in">stack</span>&lt; pair&lt;TreeNode *, <span class="hljs-keyword">bool</span>&gt; &gt; s;
    <span class="hljs-comment">// æ³¨æ„ï¼š make_pairä¸èƒ½ä½¿ç”¨å°–æ‹¬å·"&lt;&gt;"</span>
    s.push(make_pair(root, <span class="hljs-literal">false</span>));
    <span class="hljs-keyword">bool</span> visited;
    <span class="hljs-keyword">while</span>(!s.empty())
    {
        root = s.top().first;
        visited = s.top().second;
        s.pop();
        <span class="hljs-comment">// äºŒéå¤ä¹ å¿˜è®°ç‚¹ï¼šæ³¨æ„ï¼š ä¸è¦å¿˜è®°rootä¸ºç©ºçš„å¤„ç†</span>
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)
            <span class="hljs-keyword">continue</span>;
        <span class="hljs-comment">// è‹¥æ­¤å‰å·²é€šè¿‡è¯¥ç»“ç‚¹å°†å…¶å±€éƒ¨å…¥æ ˆï¼Œåˆ™ç›´æ¥å‡ºæ ˆè¾“å‡ºå³å¯</span>
        <span class="hljs-keyword">if</span>(visited)
        {
            path.push_back(root-&gt;val);
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-comment">// éé€’å½’å‰åºéå†</span>
            s.push(make_pair(root-&gt;right, <span class="hljs-literal">false</span>));
            s.push(make_pair(root-&gt;left, <span class="hljs-literal">false</span>));
            s.push(make_pair(root, <span class="hljs-literal">true</span>));    <span class="hljs-comment">// åªå‰©ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œå› æ­¤ä»stackæ‹¿å‡ºæ¥å³å¯</span>
            <span class="hljs-comment">// éé€’å½’ä¸­åºéå†</span>
            s.push(make_pair(root-&gt;right, <span class="hljs-literal">false</span>));
            s.push(make_pair(root, <span class="hljs-literal">true</span>));
            s.push(make_pair(root-&gt;left, <span class="hljs-literal">false</span>));
            <span class="hljs-comment">// éé€’å½’ååºéå†</span>
            s.push(make_pair(root, <span class="hljs-literal">true</span>));
            s.push(make_pair(root-&gt;right, <span class="hljs-literal">false</span>));
            s.push(make_pair(root-&gt;left, <span class="hljs-literal">false</span>));
        }
    }
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-comment">// éé€’å½’å‰åºéå†ç®€åŒ–</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode *root, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;path)</span>
</span>{
    <span class="hljs-built_in">stack</span>&lt;TreeNode *&gt; s;
    s.push(root);
    <span class="hljs-keyword">while</span>(!s.empty())
    {
        root = s.top();
        s.pop();
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)
        {
            <span class="hljs-keyword">continue</span>;
        }
        <span class="hljs-keyword">else</span>
        {
            path.push_back(root-&gt;val);
            s.push(root-&gt;right);
            s.push(root-&gt;left);
        }
    }
}
</div></code></pre>
</li>
</ul>
<ol>
<li>æ•™ç§‘ä¹¦ä¸Šçš„éé€’å½’éå†<pre class="hljs"><code><div><span class="hljs-comment">//éé€’å½’å‰åºéå†</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode *root, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;path)</span>
</span>{
    <span class="hljs-built_in">stack</span>&lt;TreeNode *&gt; s;
    TreeNode *p = root;
    <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">NULL</span> || !s.empty())
    {
        <span class="hljs-comment">// æ²¿å·¦å­æ ‘ä¸€ç›´å¾€ä¸‹æœç´¢ï¼Œç›´è‡³å‡ºç°æ²¡æœ‰å·¦å­æ ‘çš„ç»“ç‚¹</span>
        <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">NULL</span>)
        {
            path.push_back(p-&gt;val);
            s.push(p);
            p = p-&gt;left;
        }
        <span class="hljs-keyword">if</span>(!s.empty())
        {
            p = s.top();
            s.pop();
            p = p-&gt;right;
        }
    }
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-comment">//éé€’å½’ä¸­åºéå†</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode *root, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;path)</span>
</span>{
    <span class="hljs-built_in">stack</span>&lt;TreeNode *&gt; s;
    TreeNode *p = root;
    <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">NULL</span> || !s.empty())
    {
        <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">NULL</span>)
        {
            s.push(p);
            p = p-&gt;left;
        }
        <span class="hljs-keyword">if</span>(!s.empty())
        {
            p = s.top();
            path.push_back(p-&gt;val);
            s.pop();
            p = p-&gt;right;
        }
    }
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-comment">// éé€’å½’ååºéå†</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">posOrderUnRecur</span><span class="hljs-params">(TreeNode* root)</span> </span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) {
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">stack</span>&lt;TreeNode*&gt; s1, s2;
    s1.push(root);
    <span class="hljs-keyword">while</span> (!s1.empty()) {
        TreeNode* root = s1.top();
        s2.push(root);
        s1.pop();
        <span class="hljs-keyword">if</span> (root-&gt;left != <span class="hljs-literal">nullptr</span>) {
            s1.push(root-&gt;left);
        }
        <span class="hljs-keyword">if</span> (root-&gt;right != <span class="hljs-literal">nullptr</span>) {
            s1.push(root-&gt;right);
        }
    }
    <span class="hljs-keyword">while</span> (!s2.empty()) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; s2.top()-&gt;value &lt;&lt; <span class="hljs-string">","</span>;
        s2.pop();
    }
}
</div></code></pre>
</li>
</ol>
<hr>
<div id="bfs" onclick="window.location.hash">
<h4 id="2-%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6-bfs">2. [ä»£ç æ¡†æ¶] BFS</h4>
<ul>
<li>
<p>é˜Ÿåˆ— q å°±ä¸è¯´äº†ï¼ŒBFS çš„æ ¸å¿ƒæ•°æ®ç»“æ„ï¼›</p>
</li>
<li>
<p>cur.adj() æ³›æŒ‡ cur ç›¸é‚»çš„èŠ‚ç‚¹ï¼Œæ¯”å¦‚è¯´äºŒç»´æ•°ç»„ä¸­ï¼Œcur ä¸Šä¸‹å·¦å³å››é¢çš„ä½ç½®å°±æ˜¯ç›¸é‚»èŠ‚ç‚¹ï¼›</p>
</li>
<li>
<p>visited çš„ä¸»è¦ä½œç”¨æ˜¯é˜²æ­¢èµ°å›å¤´è·¯ï¼Œå¤§éƒ¨åˆ†æ—¶å€™éƒ½æ˜¯å¿…é¡»çš„ï¼Œä½†æ˜¯åƒä¸€èˆ¬çš„äºŒå‰æ ‘ç»“æ„ï¼Œæ²¡æœ‰å­èŠ‚ç‚¹åˆ°çˆ¶èŠ‚ç‚¹çš„æŒ‡é’ˆï¼Œä¸ä¼šèµ°å›å¤´è·¯å°±ä¸éœ€è¦ visitedã€‚</p>
<pre class="hljs"><code><div><span class="hljs-comment">// è®¡ç®—ä»èµ·ç‚¹ start åˆ°ç»ˆç‚¹ target çš„æœ€è¿‘è·ç¦»</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">BFS</span><span class="hljs-params">(TreeNode start, TreeNode target)</span> 
</span>{
    Queue&lt;TreeNode&gt; q; <span class="hljs-comment">// æ ¸å¿ƒæ•°æ®ç»“æ„</span>
    Set&lt;TreeNode&gt; visited; <span class="hljs-comment">// é¿å…èµ°å›å¤´è·¯</span>

    q.offer(start); <span class="hljs-comment">// å°†èµ·ç‚¹åŠ å…¥é˜Ÿåˆ—</span>
    visited.add(start);
    <span class="hljs-keyword">int</span> step = <span class="hljs-number">0</span>; <span class="hljs-comment">// è®°å½•æ‰©æ•£çš„æ­¥æ•°</span>

    <span class="hljs-keyword">while</span> (q <span class="hljs-keyword">not</span> empty) {
        <span class="hljs-keyword">int</span> sz = q.size();
        <span class="hljs-comment">/* å°†å½“å‰é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹å‘å››å‘¨æ‰©æ•£ */</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sz; i++) {
            TreeNode cur = q.poll();
            <span class="hljs-comment">/* åˆ’é‡ç‚¹ï¼šè¿™é‡Œåˆ¤æ–­æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹ */</span>
            <span class="hljs-keyword">if</span> (cur is target)
                <span class="hljs-keyword">return</span> step;
            <span class="hljs-comment">/* å°† cur çš„ç›¸é‚»èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ— */</span>
            <span class="hljs-keyword">for</span> (TreeNode x : cur.adj())
                <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">not</span> in visited) {
                    q.offer(x);
                    visited.add(x);
                }
        }
        <span class="hljs-comment">/* åˆ’é‡ç‚¹ï¼šæ›´æ–°æ­¥æ•°åœ¨è¿™é‡Œ */</span>
        step++;
    }
}
</div></code></pre>
</li>
</ul>
<hr>
<div id="mdobt" onclick="window.location.hash">
<h4 id="3-maximum-depth-of-binary-tree104">3. maximum-depth-of-binary-tree(#104)</h4>
<p>linkage: <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" title="äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦">leetcode</a></p>
<blockquote>
<p>ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾å‡ºå…¶æœ€å¤§æ·±åº¦</p>
</blockquote>
<ul>
<li><strong>é€’å½’æ–¹å¼</strong>
<ul>
<li>ä¸‰ä¸ªæ¡ä»¶ï¼šé€’å½’å®šä¹‰ï¼Œé€’å½’å‡ºå£ï¼Œé€’å½’æ‹†è§£<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span>
    </span>{
        <span class="hljs-comment">// recursive function</span>
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)
        {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+<span class="hljs-built_in">std</span>::max(maxDepth(root-&gt;left),maxDepth(root-&gt;right));
    }
};
</div></code></pre>
</li>
</ul>
</li>
<li><strong>BFS</strong>ï¼šä½¿ç”¨é˜Ÿåˆ—<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span>
    </span>{
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">deque</span>&lt;TreeNode*&gt; q;
        q.push_back(root);
        <span class="hljs-keyword">int</span> deep = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(!q.empty())
        {
            deep ++;
            <span class="hljs-keyword">int</span> num = q.size();
            <span class="hljs-comment">// æ³¨æ„å¿…é¡»ç”¨numèµ‹å€¼ï¼Œå› ä¸ºåé¢ä¼šå¯¹q.size()è¿›è¡Œæ“ä½œ</span>
            <span class="hljs-comment">// ä¸å¯ç”¨ for(int i = 0; i&lt;q.size();i++)</span>
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++)
            {
                TreeNode* p = q.front();
                q.pop_front();
                <span class="hljs-keyword">if</span>(p-&gt;left) q.push_back(p-&gt;left);
                <span class="hljs-keyword">if</span>(p-&gt;right) q.push_back(p-&gt;right);
            }
        }
        <span class="hljs-keyword">return</span> deep;
    }
};
</div></code></pre>
</li>
<li>DFSï¼šç”¨æ ˆçš„å¾ªç¯ç‰ˆ
<img src=".readme/dfs.png" alt="alt text" title="dfs"><pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span>
    </span>{
        <span class="hljs-comment">// DFS </span>
        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) {<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}
        <span class="hljs-keyword">int</span> curHeight = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> maxHeight = <span class="hljs-number">0</span>;
        findMaxHeight(root, curHeight,maxHeight); 
        <span class="hljs-keyword">return</span> maxHeight;
    }
    
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findMaxHeight</span><span class="hljs-params">(TreeNode* _root, <span class="hljs-keyword">int</span>&amp; _curHeight, <span class="hljs-keyword">int</span>&amp; _maxHeight)</span>
    </span>{
        _curHeight += <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (_root -&gt; left != <span class="hljs-literal">nullptr</span> || _root -&gt; right != <span class="hljs-literal">nullptr</span>)
        {
            <span class="hljs-keyword">if</span>(_root -&gt; left != <span class="hljs-literal">nullptr</span>)
            {
                findMaxHeight(_root -&gt; left, _curHeight, _maxHeight);
                _curHeight -= <span class="hljs-number">1</span>;
            }
            <span class="hljs-comment">// æ³¨æ„ï¼šä¸è¦ä½¿ç”¨else if</span>
            <span class="hljs-keyword">if</span>(_root -&gt; right != <span class="hljs-literal">nullptr</span>)
            {
                findMaxHeight(_root -&gt; right, _curHeight, _maxHeight);
                _curHeight -= <span class="hljs-number">1</span>;
            }
        }
        <span class="hljs-keyword">else</span>
        {
            _maxHeight = <span class="hljs-built_in">std</span>::max(_curHeight,_maxHeight);
        }
    }
};
</div></code></pre>
</li>
</ul>
<hr>
<div id="bbt" onclick="window.location.hash">
<h4 id="4-balanced-binary-tree110">4. balanced-binary-tree(#110)</h4>
<p>linkage: <a href="https://leetcode-cn.com/problems/balanced-binary-tree/" title="é«˜åº¦å¹³è¡¡çš„äºŒå‰æ ‘">leetcode</a></p>
<blockquote>
<p>é«˜åº¦å¹³è¡¡äºŒå‰æ ‘ï¼š æ¯ä¸ªèŠ‚ç‚¹å·¦å³å­æ ‘çš„é«˜åº¦å·®ä¸è¶…è¿‡1</p>
</blockquote>
<ul>
<li>æ€è·¯:<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> 
    </span>{
        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)
        {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">abs</span>(heightTree(root-&gt;left)-heightTree(root-&gt;right))&lt;<span class="hljs-number">2</span>
            &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);
    }
    
<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">heightTree</span><span class="hljs-params">(TreeNode* root)</span>
    </span>{
        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)
        {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+<span class="hljs-built_in">std</span>::max(heightTree(root-&gt;left),heightTree(root-&gt;right));
    }
};
</div></code></pre>
</li>
</ul>
<hr>
<div id="btnps" onclick="window.location.hash">
<h4 id="5-binary-tree-maximum-path-sum124">5. binary-tree-maximum-path-sum(#124)</h4>
<p>linkage: <a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" title="äºŒå‰æ ‘ä¸­çš„æœ€å¤§è·¯å¾„å’Œ">leetcode</a></p>
<blockquote>
<p>ç»™å®šä¸€ä¸ªéç©ºäºŒå‰æ ‘ï¼Œè¿”å›å…¶æœ€å¤§è·¯å¾„å’Œ</p>
</blockquote>
<ul>
<li>æ€è·¯ï¼šç†è§£å¦‚ä½•é€’å½’å¾ˆå…³é”®<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> 
    </span>{
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)
        {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
        dfs(root);
        <span class="hljs-keyword">return</span> maxValue_;
    }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span>
    </span>{
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)
        {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
        <span class="hljs-keyword">int</span> leftMax = <span class="hljs-built_in">std</span>::max(<span class="hljs-number">0</span>,dfs(root-&gt;left));
        <span class="hljs-keyword">int</span> rightMax = <span class="hljs-built_in">std</span>::max(<span class="hljs-number">0</span>,dfs(root-&gt;right));
        maxValue_ = <span class="hljs-built_in">std</span>::max(maxValue_,root-&gt;val+leftMax+rightMax);
        <span class="hljs-keyword">return</span> root-&gt;val + <span class="hljs-built_in">std</span>::max(leftMax,rightMax);
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> kMinInt = INT_MIN;
    <span class="hljs-keyword">int</span> maxValue_ = kMinInt;
};
</div></code></pre>
</li>
</ul>
<hr>
<div id="lcaoabt" onclick="window.location.hash">
<h4 id="6-lowest-common-ancestor-of-a-binary-tree236">6. lowest-common-ancestor-of-a-binary-tree(#236)</h4>
<p>linkage: <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" title="äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ">leetcode</a></p>
<blockquote>
<p>ç»™å®šä¸€ä¸ªäºŒå‰æ ‘, æ‰¾åˆ°è¯¥æ ‘ä¸­ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ</p>
</blockquote>
<ul>
<li>
<p><strong>ADT</strong>
left == null &amp;&amp; right == null return null
left == null &amp;&amp; right ï¼= null return right
right == null &amp;&amp; left ï¼= null return left
right ï¼= null &amp;&amp; left ï¼=null return root</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span>
    </span>{
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)
        {
            <span class="hljs-keyword">return</span> root;
        }
        <span class="hljs-keyword">if</span>(root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val)
        {
            <span class="hljs-keyword">return</span> root;
        }
        TreeNode* left_son = lowestCommonAncestor(root-&gt;left,p,q);
        TreeNode* right_son = lowestCommonAncestor(root-&gt;right,p,q);
        <span class="hljs-keyword">if</span>(left_son == <span class="hljs-literal">NULL</span> &amp;&amp; right_son == <span class="hljs-literal">NULL</span>)
        {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
        }
        <span class="hljs-keyword">if</span>(left_son != <span class="hljs-literal">NULL</span> &amp;&amp; right_son == <span class="hljs-literal">NULL</span>)
        {
            <span class="hljs-keyword">return</span> left_son;
        }
        <span class="hljs-keyword">if</span>(left_son == <span class="hljs-literal">NULL</span> &amp;&amp; right_son != <span class="hljs-literal">NULL</span>)
        {
            <span class="hljs-keyword">return</span> right_son;
        }
        <span class="hljs-keyword">if</span>(left_son != <span class="hljs-literal">NULL</span> &amp;&amp; right_son != <span class="hljs-literal">NULL</span>)
        {
            <span class="hljs-keyword">return</span> root;
        }
        <span class="hljs-keyword">return</span> root;
    }
};
</div></code></pre>
</li>
</ul>
<hr>
<div id="btlot" onclick="window.location.hash">
<h4 id="7-binary-tree-level-order-traversal102">7. binary-tree-level-order-traversal(#102)</h4>
<p>linkage: <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/submissions/" title="äºŒå‰æ ‘çš„å±‚åºéå†">leetcode</a></p>
<blockquote>
<p>ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¯·ä½ è¿”å›å…¶æŒ‰å±‚åºéå†å¾—åˆ°çš„èŠ‚ç‚¹å€¼
å³é€å±‚åœ°ï¼Œä»å·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹</p>
</blockquote>
<ul>
<li><strong>æ³¨æ„c++ä¸­queue()[push,pop]å’Œdeque()[push_back,pop_front]çš„ä½¿ç”¨</strong></li>
<li>DFS ä¸ BFSåŒºåˆ«
<ol>
<li>DFSéå†çš„ä»£ç æ¯”BFSç®€æ´å¤ªå¤šäº†ï¼</li>
<li>å› ä¸ºé€’å½’çš„æ–¹å¼éšå«åœ°ä½¿ç”¨äº†ç³»ç»Ÿçš„æ ˆï¼Œæˆ‘ä»¬ä¸éœ€è¦è‡ªå·±ç»´æŠ¤ä¸€ä¸ªæ•°æ®ç»“æ„ã€‚</li>
<li>å¦‚æœåªæ˜¯ç®€å•åœ°å°†äºŒå‰æ ‘éå†ä¸€éï¼Œé‚£ä¹ˆDFSæ˜¾ç„¶æ˜¯æ›´æ–¹ä¾¿çš„é€‰æ‹©</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root)</span>
</span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)
    {
        <span class="hljs-keyword">return</span>;
    }
    dfs(root.left);
    dfs(root.right);
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(TreeNode root)</span>
</span>{
    <span class="hljs-comment">// æ³¨æ„c++ä¸ºdeque</span>
    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();
    queue.add(root);
    <span class="hljs-keyword">while</span> (!queue.isEmpty())
    {
        TreeNode node = queue.poll();
        <span class="hljs-comment">// Java çš„ pop å†™ä½œ poll()</span>
        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>)
        {
            queue.add(node.left);
        }
        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>)
        {
            queue.add(node.right);
        }
    }
}
</div></code></pre>
</li>
<li>BFS cppä»£ç <pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode* root)</span> 
    </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; level_lists;
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)
        {
            <span class="hljs-keyword">return</span> level_lists;
        }
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;
        q.push(root);
        <span class="hljs-keyword">while</span>(!q.empty())
        {
            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; level_list;
            <span class="hljs-keyword">int</span> num = q.size();
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num;i++)
            {
                <span class="hljs-comment">// äºŒéé‡åšï¼šæ³¨æ„queueä¸ºfront</span>
                TreeNode* cur = q.front();
                level_list.push_back(cur-&gt;val);
                q.pop();
                <span class="hljs-comment">// æ³¨æ„æ¯ä¸€å±‚çš„å¤„ç†</span>
                <span class="hljs-keyword">if</span>(cur-&gt;left != <span class="hljs-literal">NULL</span>) q.push(cur-&gt;left);
                <span class="hljs-keyword">if</span>(cur-&gt;right != <span class="hljs-literal">NULL</span>) q.push(cur-&gt;right);
            }
            level_lists.push_back(level_list);
        }
        <span class="hljs-keyword">return</span> level_lists;
    }
};
</div></code></pre>
</li>
</ul>
<hr>
<div id="btlotii" onclick="window.location.hash">
<h4 id="8-binary-tree-level-order-traversal-ii107">8. binary-tree-level-order-traversal-ii(#107)</h4>
<p>linkage: <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" title="äºŒå‰æ ‘çš„å±‚æ¬¡éå† II">leetcode</a></p>
<blockquote>
<p>ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼è‡ªåº•å‘ä¸Šçš„å±‚æ¬¡éå†ã€‚
å³æŒ‰ä»å¶å­èŠ‚ç‚¹æ‰€åœ¨å±‚åˆ°æ ¹èŠ‚ç‚¹æ‰€åœ¨çš„å±‚ï¼Œé€å±‚ä»å·¦å‘å³éå†</p>
</blockquote>
<ul>
<li><strong>æ³¨æ„BFSåšæ³•:</strong>
<ol>
<li>ä¸7ç±»ä¼¼,éœ€è¦ç”¨std::listæ¯æ¬¡éƒ½å¾€é˜Ÿå¤´å¡**</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; level_lists;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; level_vectors;
level_vectors.assign(level_lists.begin(),level_lists.end());
</div></code></pre>
<ol start="2">
<li>ç”¨std::reverseå‡½æ•°å®ç°</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; level_vectors;
<span class="hljs-built_in">std</span>::reverse(level_vectors.begin(),level_vectors.end());
</div></code></pre>
</li>
<li>æœ¬é¢˜è¿˜å¯ç”¨DFSå®ç°(ç•¥)</li>
</ul>
<hr>
<div id="btzlot" onclick="window.location.hash">
<h4 id="9-binary-tree-zigzag-level-order-traversal103">9. binary-tree-zigzag-level-order-traversal(#103)</h4>
<p>linkage: <a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" title="äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚æ¬¡éå†">leetcode</a></p>
<blockquote>
<p>ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„é”¯é½¿å½¢å±‚æ¬¡éå†ã€‚</p>
</blockquote>
<ul>
<li><strong>æ³¨æ„BFSåšæ³•:</strong>
<ol>
<li>å¯¹åº”å±‚åˆ¤æ–­ä¸€ä¸‹å¥‡å¶</li>
</ol>
<pre class="hljs"><code><div> <span class="hljs-comment">// æ³¨æ„ä¸!levels%2åŒºåˆ«</span>
 <span class="hljs-comment">// è¯¥æ®µä»£ç ä¸èƒ½æ”¾å…¥å¾ªç¯ä½“å†…éƒ¨</span>
 <span class="hljs-keyword">if</span> (!(levels%<span class="hljs-number">2</span>))
 {
     <span class="hljs-built_in">std</span>::reverse(level_value.begin(),level_value.end());
 }
</div></code></pre>
</li>
</ul>
<hr>
<div id="vbst" onclick="window.location.hash">
<h4 id="10-validate-binary-search-tree98">10. validate-binary-search-tree(#98)</h4>
<p>linkage: <a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" title="éªŒè¯äºŒå‰æœç´¢æ ‘">leetcode</a></p>
<blockquote>
<p>ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œåˆ¤æ–­å…¶æ˜¯å¦æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„äºŒå‰æœç´¢æ ‘</p>
</blockquote>
<ul>
<li>æ€è·¯ä¸€ï¼š<strong>åˆ©ç”¨Recursionæ–¹æ³•</strong><pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span>
    </span>{
        <span class="hljs-keyword">return</span> recursionBST(root,LONG_MAX, LONG_MIN);
    }

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">recursionBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">long</span> max, <span class="hljs-keyword">long</span> min)</span>
    </span>{
        <span class="hljs-comment">// é€’å½’çš„å‡ºå£</span>
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)
        {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
        <span class="hljs-comment">//é€’å½’çš„åˆ¤æ–­æ¡ä»¶</span>
        <span class="hljs-keyword">if</span>(root-&gt;val &gt;= max || root-&gt;val &lt;= min)
        {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">return</span> recursionBST(root-&gt;left, root-&gt;val, min) &amp;&amp; recursionBST(root-&gt;right, max, root-&gt;val);
    }
};
</div></code></pre>
</li>
<li>æ€è·¯äºŒï¼šä¸­åºéå†æ–¹å¼
äºŒå‰æœç´¢æ ‘ä¸€ä¸ªæ˜æ˜¾çš„ç‰¹ç‚¹å°±æ˜¯<strong>ä¸­åºéå†ä»¥åæ˜¯ä¸€ä¸ªæœ‰åºæ•°ç»„</strong>ï¼Œé€šè¿‡è¿™ä¸ªå¯¹æ¯”åˆ¤æ–­æ˜¯å¦äºŒå‰æœç´¢æ ‘
<ul>
<li>é€’å½’ç‰ˆæœ¬<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> 
    </span>{
        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)
        {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
        inOrderTraversal(root);
        <span class="hljs-keyword">int</span> inorder_num = inorder_lists_.size();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;inorder_num;i++)
        {
            <span class="hljs-keyword">if</span>(inorder_lists_[i<span class="hljs-number">-1</span>]&gt;=inorder_lists_[i])
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrderTraversal</span><span class="hljs-params">(TreeNode* root)</span>
    </span>{
        <span class="hljs-comment">// æ³¨æ„recursionçš„å‡ºå£</span>
        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">nullptr</span>)
        {
            inOrderTraversal(root-&gt;left);
            inorder_lists_.push_back(root-&gt;val);
            inOrderTraversal(root-&gt;right);
        }
        
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int64_t</span>&gt; inorder_lists_;
};
</div></code></pre>
</li>
</ul>
</li>
<li>éé€’å½’ç‰ˆæœ¬ <strong>æ›´ç®€å•çš„éé€’å½’éå†äºŒå‰æ ‘ç‰ˆæœ¬ä¸€è‡´</strong><pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>{
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)
        {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
        inOrderTravesal(root);
        <span class="hljs-keyword">int</span> num = vector_paths_.size();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;num<span class="hljs-number">-1</span>;i++)
        {
            <span class="hljs-keyword">if</span>(vector_paths_[i]&gt;=vector_paths_[i+<span class="hljs-number">1</span>])
            {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrderTravesal</span><span class="hljs-params">(TreeNode* root)</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">stack</span>&lt;<span class="hljs-built_in">std</span>::pair&lt;TreeNode*,<span class="hljs-keyword">bool</span>&gt;&gt; s;
        s.push(<span class="hljs-built_in">std</span>::make_pair(root,<span class="hljs-literal">false</span>));
        <span class="hljs-keyword">bool</span> visited;
        <span class="hljs-keyword">while</span>(!s.empty())
        {
            root = s.top().first;
            visited = s.top().second;
            s.pop();
            <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)
            {
                <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-comment">// é‡ç‚¹æ ¸å¿ƒ: æ­¤å‰å·²é€šè¿‡è¯¥ç»“ç‚¹å°†å…¶å±€éƒ¨å…¥æ ˆï¼Œåˆ™ç›´æ¥å‡ºæ ˆè¾“å‡º</span>
            <span class="hljs-keyword">if</span>(visited)
            {
                vector_paths_.push_back(root-&gt;val);
            }
            <span class="hljs-keyword">else</span>
            {
                s.push(<span class="hljs-built_in">std</span>::make_pair(root-&gt;right,<span class="hljs-literal">false</span>));
                s.push(<span class="hljs-built_in">std</span>::make_pair(root,<span class="hljs-literal">true</span>));
                s.push(<span class="hljs-built_in">std</span>::make_pair(root-&gt;left,<span class="hljs-literal">false</span>));
            }
        }
    }
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int64_t</span>&gt; vector_paths_;
};
</div></code></pre>
</li>
</ul>
<hr>
<div id="iiabst" onclick="window.location.hash">
<h4 id="11-insert-into-a-binary-search-tree701">11. insert-into-a-binary-search-tree(#701)</h4>
<p>linkage: <a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" title="äºŒå‰æœç´¢æ ‘ä¸­çš„æ’å…¥æ“ä½œ">leetcode</a></p>
<blockquote>
<p>ç»™å®šBSTæ ¹èŠ‚ç‚¹å’Œè¦æ’å…¥çš„å€¼ï¼Œå°†å€¼æ’å…¥äºŒå‰æœç´¢æ ‘
è¿”å›æ’å…¥åäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œä¸æ’å…¥å­˜åœ¨çš„å€¼ã€‚
ç¬¦åˆäºŒå‰æœç´¢æ ‘å³å¯ï¼Œä¸éœ€è¦ç»´æŠ¤å­æ ‘é«˜åº¦å·®</p>
</blockquote>
<ul>
<li>æ€è·¯ä¸€ï¼š<strong>DFS Recursion</strong>
1ã€è‹¥ root == nullï¼Œåˆ™è¿”å› TreeNode(val)ã€‚
2ã€è‹¥ val &gt; root.valï¼Œæ’å…¥åˆ°å³å­æ ‘
3ã€è‹¥ val &lt; root.valï¼Œæ’å…¥åˆ°å·¦å­æ ‘
4ã€è¿”å› root</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">TreeNode* <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> val)</span> </span>{
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)
        {
            <span class="hljs-comment">// æ³¨æ„ï¼š è¿”å›ä¸€ä¸ªnew TreeNode</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode(val);
        }
        <span class="hljs-keyword">if</span>(val &gt; root-&gt;val)
        {
            <span class="hljs-comment">// æ³¨æ„ï¼šå‘å³é€’å½’åè¿”å›ç»“æœ</span>
            root-&gt;right = insertIntoBST(root-&gt;right, val);
        }
        <span class="hljs-keyword">if</span>(val &lt; root-&gt;val)
        {
            root-&gt;left = insertIntoBST(root-&gt;left, val);
        }
        <span class="hljs-keyword">return</span> root;
    }
};
</div></code></pre>
<ul>
<li>æ€è·¯äºŒï¼š<strong>è¿­ä»£éRecursion</strong>
1ã€äºŒå‰æœç´¢æ ‘ï¼Œå¦‚æœvalå°äºç­‰äºå½“å‰èŠ‚ç‚¹ï¼Œå‘å·¦éå†ï¼›è‹¥å¤§äºå½“å‰èŠ‚ç‚¹ï¼Œåˆ™å‘å³éå†
2ã€ç»ˆæ­¢æ¡ä»¶ä¸ºä¸‹ä¸€ä¸ªéå†èŠ‚ç‚¹ä¸ºç©ºï¼Œè¿™ä¸ªèŠ‚ç‚¹ä¹Ÿå°±æ˜¯éœ€è¦æ’å…¥èŠ‚ç‚¹çš„ä½ç½®
3ã€åœ¨å¼€å§‹éœ€è¦ä¿å­˜ä¸€ä¸ªrootæŒ‡é’ˆï¼Œç”¨äºå½“åšè¿”å›ç»“æœ<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">TreeNode* <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> val)</span> 
    </span>{
        <span class="hljs-comment">// é‡ç‚¹1ï¼šä¸€å®šèµ‹äºˆä¸´æ—¶å˜é‡ï¼Œ ç›´æ¥æ“ä½œrootåªè¿”å›æ’å…¥åçš„ä¸‰ä¸ªå€¼</span>
        TreeNode* res = root;
        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)
        {
            <span class="hljs-comment">// æ³¨æ„è¦new</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode(val);
        }
        <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">nullptr</span>)
        {
            <span class="hljs-keyword">if</span>(val &lt; root-&gt;val)
            {
                <span class="hljs-keyword">if</span>(root-&gt;left ==<span class="hljs-literal">nullptr</span>)
                {
                    root-&gt;left = <span class="hljs-keyword">new</span> TreeNode(val);
                    <span class="hljs-keyword">break</span>;
                }
                <span class="hljs-keyword">else</span>
                {
                    <span class="hljs-comment">//é‡ç‚¹2ï¼šå°†ä¸‹ä¸€èŠ‚ç‚¹èµ‹äºˆå½“å‰æŒ‡é’ˆ</span>
                    root = root-&gt;left;
                }
            }
            <span class="hljs-keyword">if</span>(val &gt; root-&gt;val)
            {
                <span class="hljs-keyword">if</span>(root-&gt;right ==<span class="hljs-literal">nullptr</span>)
                {
                    root-&gt;right = <span class="hljs-keyword">new</span> TreeNode(val);
                    <span class="hljs-keyword">break</span>;
                }
                <span class="hljs-keyword">else</span>
                {
                    root = root-&gt;right;
                }
            }
        }
        <span class="hljs-keyword">return</span> res;
    }
};
</div></code></pre>
</li>
</ul>
<hr>
<div id="dniab" onclick="window.location.hash">
<h4 id="12-delete-node-in-a-bst450">12. delete-node-in-a-bst(#450)</h4>
<p>linkage: <a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" title="åˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„èŠ‚ç‚¹">leetcode</a></p>
<blockquote>
<p>ç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹rootå’Œä¸€ä¸ªå€¼keyï¼Œåˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„keyå¯¹åº”çš„èŠ‚ç‚¹
è¿”å›æ ¹èŠ‚ç‚¹</p>
</blockquote>
<ul>
<li>æ€è·¯ä¸€ï¼šé€’å½’
<ul>
<li>æ–¹æ³•ï¼š
<ul>
<li>åˆ é™¤èŠ‚ç‚¹åˆ†ä¸ºä¸¤æ­¥ï¼Œ 1. æ‰¾åˆ°åˆ é™¤ä½ç½®ï¼› 2. åˆ†æä¸åŒæƒ…å†µ</li>
<li>ç”»å›¾åˆ†æå¯çŸ¥ï¼š
<ul>
<li>
<ol>
<li>å½“åˆ é™¤èŠ‚ç‚¹åœ¨å¶å­èŠ‚ç‚¹ï¼Œä»£ç ï¼š</li>
</ol>
<pre class="hljs"><code><div>root = <span class="hljs-literal">nullptr</span>
</div></code></pre>
<img src=".readme/del_bst1.png" alt="" title="delete bst"></li>
<li>
<ol start="2">
<li>å½“èŠ‚ç‚¹åœ¨åç»§successorä¸Šï¼Œæ‰¾åˆ°å…¶å³å­æ ‘å¯¹åº”çš„å·¦èŠ‚ç‚¹,ä»£ç å¦‚ä¸‹ï¼š</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-function">TreeNode* <span class="hljs-title">successorNode</span><span class="hljs-params">(TreeNode* root)</span>
</span>{
    root = root-&gt;right;
    <span class="hljs-keyword">while</span>(root-&gt;left != <span class="hljs-literal">nullptr</span>)
    {
        root = root-&gt;left;
    }
    <span class="hljs-keyword">return</span> root;
}
</div></code></pre>
<img src=".readme/del_bst2.png" alt="" title="delete bst"></li>
<li>
<ol start="3">
<li>èŠ‚ç‚¹åœ¨å‰é©±predecessorä¸Šï¼Œæ‰¾åˆ°å…¶å·¦å­æ ‘å¯¹åº”çš„å³èŠ‚ç‚¹</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-function">TreeNode* <span class="hljs-title">predecessorNode</span><span class="hljs-params">(TreeNode* root)</span>
</span>{
    root = root-&gt;left;
    <span class="hljs-keyword">while</span>(root-&gt;right != <span class="hljs-literal">nullptr</span>)
    {
        root = root-&gt;right;
    }
    <span class="hljs-keyword">return</span> root;
}
</div></code></pre>
<img src=".readme/del_bst3.png" alt="" title="delete bst"></li>
</ul>
</li>
<li>æœ€ç»ˆåˆ©ç”¨é€’å½’ï¼Œä»£ç å¦‚ä¸‹ï¼š</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> key)</span> 
    </span>{
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)
        {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
        }
        <span class="hljs-comment">// åˆ©ç”¨é€’å½’æ‰¾åˆ°å¯¹åº”èŠ‚ç‚¹</span>
        <span class="hljs-keyword">if</span>(key &lt; root-&gt;val)
        {
            <span class="hljs-comment">// è¿”å›å€¼èµ·åˆ°è¿æ¥æŒ‡å‘</span>
            root-&gt;left = deleteNode(root-&gt;left, key);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &gt; root-&gt;val)
        {
            root-&gt;right = deleteNode(root-&gt;right, key);
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-comment">//æ‰¾åˆ°keyï¼Œåˆ†ä¸‰ç§æƒ…å†µ</span>
            <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>)
            {
                root = <span class="hljs-literal">nullptr</span>;
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;right != <span class="hljs-literal">nullptr</span>)
            {
                <span class="hljs-comment">// æ‰¾åé©±èŠ‚ç‚¹</span>
                root-&gt;val = successorNode(root);
                root-&gt;right = deleteNode(root-&gt;right,root-&gt;val);
            }
            <span class="hljs-keyword">else</span>
            {
                root-&gt;val = predecessorNode(root);
                root-&gt;left = deleteNode(root-&gt;left,root-&gt;val);
            }
        }
        <span class="hljs-keyword">return</span> root;
    }

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">successorNode</span><span class="hljs-params">(TreeNode* root)</span>
    </span>{
        root = root-&gt;right;
        <span class="hljs-keyword">while</span>(root-&gt;left != <span class="hljs-literal">nullptr</span>)
        {
            root = root-&gt;left;
        }
        <span class="hljs-keyword">return</span> root-&gt;val;
    }

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">predecessorNode</span><span class="hljs-params">(TreeNode* root)</span>
    </span>{
        root = root-&gt;left;
        <span class="hljs-keyword">while</span>(root-&gt;right != <span class="hljs-literal">nullptr</span>)
        {
            root = root-&gt;right;
        }
        <span class="hljs-keyword">return</span> root-&gt;val;
    }
};
</div></code></pre>
</li>
</ul>
</li>
</ul>

</body>
</html>
